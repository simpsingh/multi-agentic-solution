"""
Metadata Pydantic Schemas

21-field column schema for document parsing and metadata storage.
"""

from pydantic import BaseModel, Field, field_serializer, computed_field
from datetime import datetime
from typing import Optional, List


def format_timestamp(dt: datetime) -> str:
    """Format datetime as YYYYMMDD HH:MM:SS"""
    return dt.strftime("%Y%m%d %H:%M:%S")


class ColumnSchema(BaseModel):
    """
    Schema for a single column/field in metadata (21 fields).

    Core Fields (9):
    - column_id, column_name, description, data_type, data_length,
      precision, scale, nullable, notes

    Classification (3):
    - is_header, is_body, is_trailer

    Constraints & Generation (5):
    - allowed_values, format_hint, default_value, is_system_generated,
      data_classification

    Relationships (2):
    - foreign_key_table, foreign_key_column

    Enhanced Context (2):
    - business_rule, sample_values
    """

    # Core Fields (9)
    column_id: int = Field(..., description="Column order/position (1-based)")
    column_name: str = Field(..., description="Database column name")
    description: str = Field(..., description="Business description of the field")
    data_type: str = Field(..., description="SQL data type (VARCHAR, INTEGER, DECIMAL, etc.)")
    data_length: Optional[int] = Field(None, description="Length for VARCHAR/CHAR types")
    precision: Optional[int] = Field(None, description="Precision for DECIMAL/NUMERIC types")
    scale: Optional[int] = Field(None, description="Scale for DECIMAL/NUMERIC types")
    nullable: bool = Field(..., description="Whether NULL values are allowed")
    notes: Optional[str] = Field(None, description="Additional notes or comments")

    # Classification (3)
    is_header: bool = Field(False, description="Indicates if field belongs to file header")
    is_body: bool = Field(False, description="Indicates if field belongs to file body/detail")
    is_trailer: bool = Field(False, description="Indicates if field belongs to file trailer")

    # Constraints & Generation (5)
    allowed_values: Optional[List[str]] = Field(None, description="List of valid enum values (e.g., ['CREDIT', 'DEBIT'])")
    format_hint: Optional[str] = Field(None, description="Format pattern or hint (e.g., 'ISO 4217', 'YYYYMMDD')")
    default_value: Optional[str] = Field(None, description="Default value for the column")
    is_system_generated: bool = Field(False, description="Whether value is auto-generated by system")
    data_classification: Optional[str] = Field(None, description="Data sensitivity: PII, PCI, HPR, or null")

    # Relationships (2)
    foreign_key_table: Optional[str] = Field(None, description="Referenced table name for foreign keys")
    foreign_key_column: Optional[str] = Field(None, description="Referenced column name for foreign keys")

    # Enhanced Context (2)
    business_rule: Optional[str] = Field(None, description="Business rules or validation logic")
    sample_values: Optional[List[str]] = Field(None, description="Example values for data generation")

    # Audit Timestamps (2)
    insert_timestamp: datetime = Field(default_factory=datetime.utcnow, description="Timestamp when column was first extracted")
    updated_timestamp: Optional[datetime] = Field(default=None, description="Timestamp when column was last modified (NULL on insert)")

    @field_serializer('insert_timestamp', 'updated_timestamp')
    def serialize_dt(self, dt: Optional[datetime], _info):
        """Serialize datetime to YYYYMMDD HH:MM:SS format (None becomes null)"""
        if dt is None:
            return None
        return dt.strftime("%Y%m%d %H:%M:%S")

    @computed_field
    @property
    def section_type(self) -> str:
        """Derive section_type string from boolean classification fields"""
        if self.is_header:
            return "header"
        elif self.is_trailer:
            return "trailer"
        else:
            return "body"


class DocumentInfo(BaseModel):
    """Document-level metadata"""

    title: str = Field(..., description="Document title")
    version: str = Field(..., description="Document version")
    last_updated: Optional[str] = Field(None, description="Last update date")
    description: Optional[str] = Field(None, description="Document description")


class TableSchema(BaseModel):
    """Table-level schema containing multiple columns"""

    table_name: str = Field(..., description="Database table name")
    table_description: Optional[str] = Field(None, description="Table description")
    columns: List[ColumnSchema] = Field(..., description="List of column definitions")


class MetadataJSON(BaseModel):
    """
    Complete metadata JSON structure for storing in metadata_extract table.

    This structure supports:
    - DDL generation (CREATE TABLE statements)
    - Synthetic data generation
    - Hybrid search (BM25 + vector embeddings)
    """

    version: str = Field(default="1.0", description="Schema version")
    document_info: DocumentInfo = Field(..., description="Source document metadata")
    tables: List[TableSchema] = Field(..., description="List of table definitions")


class MetadataUploadRequest(BaseModel):
    """Request schema for uploading metadata"""

    metadata_id: str
    src_doc_name: str
    src_doc_path: Optional[str] = None
    metadata_json: MetadataJSON
    description: Optional[str] = None


class MetadataResponse(BaseModel):
    """Response schema for metadata"""

    id: int
    metadata_id: str
    src_doc_name: str
    src_doc_path: str
    metadata_json: dict  # MetadataJSON
    description: Optional[str]
    status: str
    created_timestamp: datetime
    updated_timestamp: datetime

    class Config:
        from_attributes = True
